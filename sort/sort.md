# 《QG 学习周记》——排序算法专题

**2023 年 3 月 31 日**  
**作者：蒋乐**

---

## ​**一、本周学习内容**

### 1. ​**排序算法原理梳理**

- ​**插入排序**

  - ​**核心思想**：将数组分为“已排序”和“未排序”两部分，逐个将未排序元素插入到正确位置。
  - ​**时间复杂度**：最优 O(n)，最差 O(n²)，适用于小规模数据。
  - ​**代码实现**：
    ```c
    void insertsort(int* array, int num) {
        for (int i = 1; i < num; i++) {
            int sensor = array[i];
            int j = i - 1;
            while (j >= 0 && sensor < array[j]) {
                array[j + 1] = array[j];
                j--;
            }
            array[j + 1] = sensor;
        }
    }
    ```

- ​**快速排序**

  - ​**核心思想**：分治法，选取基准值（pivot）将数组分为左右两半，递归排序。
  - ​**时间复杂度**：平均 O(n log n)，最差 O(n²)（可通过随机选基准优化）。
  - ​**代码亮点**：
    ```c
    int partition(int* arr, int low, int high) {
        int pivot = arr[high];
        int i = low - 1;
        for (int j = low; j < high; j++) {
            if (arr[j] < pivot) {
                i++;
                swap(&arr[i], &arr[j]);
            }
        }
        swap(&arr[i + 1], &arr[high]);
        return i + 1;
    }
    ```

- ​**归并排序**

  - ​**核心思想**：分治法，递归拆分子数组，合并时保证有序。
  - ​**时间复杂度**：稳定 O(n log n)，适合链表和大规模数据。

- ​**基数排序**
  - ​**核心思想**：按数字位数分配至桶中，依次从低位到高位排序。
  - ​**适用场景**：整数排序，时间复杂度 O(nk)（k 为最大位数）。

---

## ​**二、实践与调试**

### 1. ​**遇到的问题**

- ​**快速排序栈溢出**

  - ​**现象**：递归深度过大导致栈溢出。
  - ​**解决方案**：改用尾递归优化或迭代实现，限制递归深度。

- ​**归并排序内存泄漏**

  - ​**现象**：`merge`函数中未释放临时数组`L`和`R`。
  - ​**修复代码**：
    ```c
    void merge(int* arr, int l, int m, int r) {
        // ...动态分配L和R...
        free(L);
        free(R); // 添加释放操作
    }
    ```

- ​**基数排序位数计算错误**
  - ​**现象**：未正确处理最大值为 0 的情况。
  - ​**调试方法**：添加日志打印中间结果，发现`max_val`初始值错误。

---

## ​**三、性能测试对比**

### 1. ​**实验设计**

- ​**测试数据**：生成 10, 1000, 10000 个随机整数。
- ​**计时工具**：Windows 高精度计时器`QueryPerformanceCounter`。

### 2. ​**结果分析**

| 算法     | 数据量=10 (ms) | 数据量=1000 (ms) | 数据量=10000 (ms) |
| -------- | -------------- | ---------------- | ----------------- |
| 插入排序 | 0.001          | 3.2              | 320.5（超时）     |
| 快速排序 | 0.002          | 0.8              | 12.3              |
| 基数排序 | 0.005          | 1.5              | 15.7              |

- ​**结论**：
  - 插入排序在小数据量时最快，但规模增大后效率骤降。
  - 快速排序综合性能最优，适合通用场景。
  - 基数排序对整数排序稳定，但需额外内存空间。

---

## ​**四、收获与反思**

1. ​**理论结合实践的重要性**

   - 通过手写排序算法，深入理解了分治法和动态规划的思想。
   - 调试过程中，学会使用**断点调试**和**日志输出**定位边界条件错误。

2. ​**性能优化的启发**

   - 快速排序的基准值选择策略（如三数取中）能显著避免最坏情况。
   - 归并排序的迭代实现可减少递归调用开销。

3. ​**下一步计划**
   - 学习堆排序和外部排序（如多路归并）。
   - 探索 C++ STL 中`std::sort`的底层实现（IntroSort：快速排序+堆排序混合）。

---

**附：核心代码仓库**  
[GitHub 链接：https://github.com/XXX/sorting-algorithms]
